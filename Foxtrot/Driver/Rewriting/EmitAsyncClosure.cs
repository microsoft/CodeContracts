using System;
using System.Collections.Generic;
using System.Compiler;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Contracts.Foxtrot.Utils;

namespace Microsoft.Contracts.Foxtrot
{
    /// <summary>
    /// Visitor that creates special closure type for async postconditions.
    /// </summary>
    /// <remarks>
    /// 
    /// Current class generate AsyncClosure with CheckMethod and CheckException methods.
    /// 
    /// Following transformation are applied to the original async method:
    /// 
    /// // This is oroginal task, generated by the AsyncTaskMethodBuilder
    /// var originalTask = t_builder.Task;
    /// 
    /// var closure = new AsyncClosure();
    /// var task2 = originalTask.ContinueWith(closure.CheckPost).Unwrap();
    /// return task2;
    /// 
    /// There are 2 cases:
    /// 1) Task has no return value.
    /// In this case only EnsuresOnThrow could be used, and we emit:
    /// Task CheckMethod(Task t)
    /// {
    ///   if (t.Status == TaskStatus.Faulted)
    ///   {
    ///     // CheckException will throw if EnsuresOnThrow is not held
    ///     CheckException(t.Exception);
    ///   }
    /// 
    ///   return t;
    /// }
    /// 
    /// 2) Task(T) reutrns a T value.
    /// In this case both EnsuresOnThrow and Contract.Ensures(Contract.Result) could be used.
    /// We emit:
    /// 
    /// Task&lt;int> CheckMethod(Task&lt;int> t)
    /// {
    ///   if (t.Status == TaskStatus.Faulted)
    ///   {
    ///     // CheckException will throw if EnsuresOnThrow is not held
    ///     CheckException(t.Exception);
    ///   }
    ///   
    ///   if (t.Status == TaskStatus.RanToCompletion)
    ///   {
    ///      // Check ensures
    ///   }
    /// }
    /// </remarks>
    internal class EmitAsyncClosure : StandardVisitor
    {
        // This assembly should be in this class but not in the SystemTypes from System.CompilerCC.
        // Moving this type there will lead to test failures and assembly resolution errors.
        private static readonly AssemblyNode/*!*/ SystemCoreAssembly = SystemTypes.GetSystemCoreAssembly(false, true);
        
        private static TypeNode TaskExtensionsTypeNode = HelperMethods.FindType(
            SystemCoreAssembly,
            Identifier.For("System.Threading.Tasks"),
            Identifier.For("TaskExtensions"));

        private static readonly Identifier CheckExceptionMethodId = Identifier.For("CheckException");
        private static readonly Identifier CheckMethodId = Identifier.For("CheckPost");

        private readonly Cache<TypeNode> aggregateExceptionType;
        private readonly Cache<TypeNode> func2Type;

        private readonly Dictionary<Local, MemberBinding> closureLocals = new Dictionary<Local, MemberBinding>();
        private readonly List<SourceContext> contractResultCapturedInStaticContext = new List<SourceContext>();

        private readonly Rewriter rewriter;
        private readonly TypeNode declaringType;
        private readonly Class closureClass;
        private readonly Class closureClassInstance;
        private readonly Specializer /*?*/ forwarder;
        private readonly Local closureLocal;

        // Fields for the CheckMethod generation
        private Method checkPostMethod;
        private StatementList checkPostBody;
        // Holds a copy of CheckMethod argument
        private Local originalResultLocal;
        private Parameter checkMethodTaskParameter;
        private readonly TypeNode checkMethodTaskType;

        public EmitAsyncClosure(Method from, Rewriter rewriter)
        {
            Contract.Requires(from != null);
            Contract.Requires(from.DeclaringType != null);
            Contract.Requires(rewriter != null);

            if (TaskExtensionsTypeNode == null)
            {
                throw new InvalidOperationException(
                    "Can't generate async closure because System.Threading.Tasks.TaskExceptions class is unavailable.");
            }

            this.rewriter = rewriter;
            this.declaringType = from.DeclaringType;

            var closureName = HelperMethods.NextUnusedMemberName(declaringType, "<" + from.Name.Name + ">AsyncContractClosure");

            this.closureClass = new Class(
                declaringModule: declaringType.DeclaringModule,
                declaringType: declaringType,
                attributes: null,
                flags: TypeFlags.NestedPrivate,
                Namespace: null,
                name: Identifier.For(closureName),
                baseClass: SystemTypes.Object,
                interfaces: null,
                members: null);

            declaringType.Members.Add(this.closureClass);
            RewriteHelper.TryAddCompilerGeneratedAttribute(this.closureClass);

            var taskType = from.ReturnType;

            this.aggregateExceptionType = new Cache<TypeNode>(() =>
                HelperMethods.FindType(rewriter.AssemblyBeingRewritten, StandardIds.System,
                    Identifier.For("AggregateException")));

            this.func2Type = new Cache<TypeNode>(() =>
                HelperMethods.FindType(SystemTypes.SystemAssembly, StandardIds.System, Identifier.For("Func`2")));

            if (from.IsGeneric)
            {
                this.closureClass.TemplateParameters = CreateTemplateParameters(closureClass, from, declaringType);

                this.closureClass.IsGeneric = true;
                this.closureClass.EnsureMangledName();

                this.forwarder = new Specializer(
                    targetModule: this.declaringType.DeclaringModule,
                    pars: from.TemplateParameters,
                    args: this.closureClass.TemplateParameters);

                this.forwarder.VisitTypeParameterList(this.closureClass.TemplateParameters);

                taskType = this.forwarder.VisitTypeReference(taskType);
            }
            else
            {
                this.closureClassInstance = this.closureClass;
            }

            this.checkMethodTaskType = taskType;

            // Emiting CheckPost method declaration
            EmitCheckPostMethodCore(checkMethodTaskType);

            // Generate closure constructor.
            // Constructor should be generated AFTER visiting type parameters in
            // the previous block of code. Otherwise current class would not have
            // appropriate number of generic arguments!
            var ctor = CreateConstructor(closureClass);
            closureClass.Members.Add(ctor);

            // Now that we added the ctor and the check method, let's instantiate the closure class if necessary
            if (this.closureClassInstance == null)
            {
                var consArgs = new TypeNodeList();
                var args = new TypeNodeList();

                var parentCount = this.closureClass.DeclaringType.ConsolidatedTemplateParameters == null
                    ? 0
                    : this.closureClass.DeclaringType.ConsolidatedTemplateParameters.Count;

                for (int i = 0; i < parentCount; i++)
                {
                    consArgs.Add(this.closureClass.DeclaringType.ConsolidatedTemplateParameters[i]);
                }

                var methodCount = from.TemplateParameters == null ? 0 : from.TemplateParameters.Count;
                for (int i = 0; i < methodCount; i++)
                {
                    consArgs.Add(from.TemplateParameters[i]);
                    args.Add(from.TemplateParameters[i]);
                }

                this.closureClassInstance =
                    (Class)
                        this.closureClass.GetConsolidatedTemplateInstance(this.rewriter.AssemblyBeingRewritten,
                            closureClass.DeclaringType, closureClass.DeclaringType, args, consArgs);
            }

            // create closure initializer for context method
            this.closureLocal = new Local(this.ClosureClass);
            this.ClosureInitializer = new Block(new StatementList());

            // TODO: What is this?
            // Add ClosureLocal instantiation?
            this.ClosureInitializer.Statements.Add(
                new AssignmentStatement(
                    this.closureLocal,
                    new Construct(new MemberBinding(null, this.Ctor), new ExpressionList())));
        }

        /// <summary>
        /// Add postconditions for the task-based methods.
        /// </summary>
        /// <remarks>
        /// Method inserts all required logic to the <paramref name="returnBlock"/> calling
        /// ContinueWith method on the <paramref name="taskBasedResult"/>.
        /// </remarks>
        public void AddAsyncPostconditions(List<Ensures> asyncPostconditions, Block returnBlock, Local taskBasedResult)
        {
            Contract.Requires(asyncPostconditions != null);
            Contract.Requires(returnBlock != null);
            Contract.Requires(taskBasedResult != null);
            Contract.Requires(asyncPostconditions.Count > 0);

            Contract.Assume(taskBasedResult.Type == checkMethodTaskType);

            // Async postconditions are impelemented using custom closure class
            // with CheckPost method that checks postconditions when the task
            // is finished.

            // Add Async postconditions to the AsyncClosure
            AddAsyncPost(asyncPostconditions);

            // Add task.ContinueWith().Unwrap(); method call to returnBlock
            AddContinueWithMethodToReturnBlock(returnBlock, taskBasedResult);
        }

        /// <summary>
        /// Returns a list of source spans where non-capturing lambdas were used.
        /// </summary>
        public IList<SourceContext> ContractResultCapturedInStaticContext
        {
            get { return contractResultCapturedInStaticContext; }
        }

        /// <summary>
        /// Instance used in calling method context
        /// </summary>
        public Class ClosureClass
        {
            get { return this.closureClassInstance; }
        }

        /// <summary>
        /// Local instance of the async closure class
        /// </summary>
        public Local ClosureLocal { get { return this.closureLocal; } }
        
        /// <summary>
        /// Block of code, responsible for closure instance initialization
        /// </summary>
        public Block ClosureInitializer { get; private set; }

        private InstanceInitializer Ctor
        {
            get { return (InstanceInitializer)this.closureClassInstance.GetMembersNamed(StandardIds.Ctor)[0]; }
        }
        
        [Pure]
        private static TypeNodeList CreateTemplateParameters(Class closureClass, Method @from, TypeNode declaringType)
        {
            var dup = new Duplicator(declaringType.DeclaringModule, declaringType);

            var templateParameters = new TypeNodeList();

            var parentCount = declaringType.ConsolidatedTemplateParameters.CountOrDefault();

            for (int i = 0; i < from.TemplateParameters.Count; i++)
            {
                var tp = HelperMethods.NewEqualTypeParameter(
                    dup, (ITypeParameter)from.TemplateParameters[i],
                    closureClass, parentCount + i);

                templateParameters.Add(tp);
            }

            return templateParameters;
        }

        private void AddContinueWithMethodToReturnBlock(Block returnBlock, Local taskBasedResult)
        {
            Contract.Requires(returnBlock != null);
            Contract.Requires(taskBasedResult != null);

            var taskType = taskBasedResult.Type;

            // To find appropriate ContinueWith method task type should be unwrapped
            var taskTemplate = HelperMethods.Unspecialize(taskType);

            var continueWithMethodLocal = GetContinueWithMethod(closureClass, taskTemplate, taskType);

            // TODO: not sure that this is possible situation when continueWith method is null. 
            // Maybe Contract.Assert(continueWithMethod != null) should be used instead!

            if (continueWithMethodLocal != null)
            {
                // We need to create delegate instance that should be passed to ContinueWith method
                var funcType = continueWithMethodLocal.Parameters[0].Type;
                var funcCtor = funcType.GetConstructor(SystemTypes.Object, SystemTypes.IntPtr);

                Contract.Assume(funcCtor != null);

                var funcLocal = new Local(funcCtor.DeclaringType);

                // Creating a method pointer to the AsyncClosure.CheckMethod
                // In this case we can't use checkMethod field.
                // Getting CheckMethod from clsoureClassInstance will provide correct (potentially updated)
                // generic arguments for enclosing type.
                var checkMethodFromClosureInstance = (Method) closureClassInstance.GetMembersNamed(CheckMethodId)[0];
                Contract.Assume(checkMethodFromClosureInstance != null);

                var ldftn = new UnaryExpression(
                    new MemberBinding(null, checkMethodFromClosureInstance),
                    NodeType.Ldftn,
                    CoreSystemTypes.IntPtr);

                // Creating delegate that would be used as a continuation for original task
                returnBlock.Statements.Add(
                    new AssignmentStatement(funcLocal,
                        new Construct(new MemberBinding(null, funcCtor),
                            new ExpressionList(closureLocal, ldftn))));

                // Wrapping continuation into TaskExtensions.Unwrap method
                // (this helps to preserve original exception and original result of the task,
                // but allows to throw postconditions violations).

                // Generating: result.ContinueWith(closure.CheckPost);
                var continueWithCall =
                    new MethodCall(
                        new MemberBinding(taskBasedResult, continueWithMethodLocal),
                        new ExpressionList(funcLocal));

                // Generating: TaskExtensions.Unwrap(result.ContinueWith(...))
                var unwrapMethod = GetUnwrapMethod(checkMethodTaskType);
                var unwrapCall =
                    new MethodCall(
                        new MemberBinding(null, unwrapMethod), new ExpressionList(continueWithCall));

                // Generating: result = Unwrap(...);
                var resultAssignment =
                    new AssignmentStatement(taskBasedResult, unwrapCall);
                returnBlock.Statements.Add(resultAssignment);
            }
        }

        /// <summary>
        /// Method generates core part of the CheckMethod
        /// </summary>
        private void EmitCheckPostMethodCore(TypeNode taskType)
        {
            Contract.Requires(taskType != null);

            this.checkMethodTaskParameter = new Parameter(Identifier.For("task"), taskType);

            // TODO ST: can I switch to new Local(taskType.Type)?!? In this case this initialization
            // could be moved outside this method
            this.originalResultLocal = new Local(new Identifier("taskLocal"), checkMethodTaskParameter.Type);

            // Generate: public Task<T> CheckPost(Task<T> task) where T is taskType or
            // public Task CheckPost(Task task) for non-generic task.
            checkPostMethod = new Method(
                declaringType: this.closureClass,
                attributes: null,
                name: CheckMethodId,
                parameters: new ParameterList(checkMethodTaskParameter),
                // was: taskType.TemplateArguments[0] when hasResult was true and SystemTypes.Void otherwise
                returnType: taskType,
                body: null);

            checkPostMethod.CallingConvention = CallingConventionFlags.HasThis;
            checkPostMethod.Flags |= MethodFlags.Public;

            this.checkPostBody = new StatementList();
            this.closureClass.Members.Add(this.checkPostMethod);

            if (taskType.IsGeneric)
            {
                // Assign taskParameter to originalResultLocal because
                // this field is used in a postcondition
                checkPostBody.Add(new AssignmentStatement(this.originalResultLocal, checkMethodTaskParameter));
            }
        }

        [ContractVerification(false)]
        private void AddAsyncPost(List<Ensures> asyncPostconditions)
        {
            var origBody = new Block(this.checkPostBody);
            origBody.HasLocals = true;

            var newBodyBlock = new Block(new StatementList());
            newBodyBlock.HasLocals = true;

            var methodBody = new StatementList();
            var methodBodyBlock = new Block(methodBody);
            methodBodyBlock.HasLocals = true;

            checkPostMethod.Body = methodBodyBlock;

            methodBody.Add(newBodyBlock);
            Block newExitBlock = new Block();
            methodBody.Add(newExitBlock);

            // Map closure locals to fields and initialize closure fields

            foreach (Ensures e in asyncPostconditions)
            {
                if (e == null) continue;

                this.Visit(e);

                if (this.forwarder != null)
                {
                    this.forwarder.Visit(e);
                }

                ReplaceResult repResult = new ReplaceResult(
                    this.checkPostMethod, this.originalResultLocal,
                    this.rewriter.AssemblyBeingRewritten);

                repResult.Visit(e);

                if (repResult.ContractResultWasCapturedInStaticContext)
                {
                    this.contractResultCapturedInStaticContext.Add(e.Assertion.SourceContext);
                }

                // now need to initialize closure result fields
                foreach (var target in repResult.NecessaryResultInitializationAsync(this.closureLocals))
                {
                    // note: target here 
                    methodBody.Add(new AssignmentStatement(target, this.originalResultLocal));
                }
            }

            // Emit normal postconditions

            SourceContext? lastEnsuresSourceContext = null;

            var ensuresChecks = new StatementList();

            Method contractEnsuresMethod = this.rewriter.RuntimeContracts.EnsuresMethod;

            foreach (Ensures e in GetTaskResultBasedEnsures(asyncPostconditions))
            {
                // TODO: Not sure that 'break' is enough! It seems that this is possible
                // only when something is broken, because normal postconditions 
                // are using Contract.Result<T>() and this is possible only for
                // generic tasks.
                if (IsVoidTask()) break; // something is wrong in the original contract

                lastEnsuresSourceContext = e.SourceContext;

                //
                // Call Contract.RewriterEnsures
                //

                ExpressionList args = new ExpressionList();
                args.Add(e.PostCondition);

                args.Add(e.UserMessage ?? Literal.Null);

                args.Add(e.SourceConditionText ?? Literal.Null);

                ensuresChecks.Add(
                    new ExpressionStatement(
                        new MethodCall(
                            new MemberBinding(null, contractEnsuresMethod),
                            args, NodeType.Call, SystemTypes.Void),
                        e.SourceContext));
            }

            this.rewriter.CleanUpCodeCoverage.VisitStatementList(ensuresChecks);

            //
            // Normal postconditions
            //

            // Wrapping normal ensures into following if statement
            // if (task.Status == TaskStatus.RanToCompletion)
            // { postcondition check }
            //
            // Implementation of this stuff is a bit tricky because if-statements
            // are inverse in the IL.
            // Basically, we need to generate following code:
            // if (!(task.Status == Task.Status.RanToCompletion))
            //   goto EndOfNormalPostcondition;
            // {postcondition check}
            // EndOfNormalPostcondition:
            // {other Code}

            // Marker for EndOfNormalPostcondition
            Block endOfNormalPostcondition = new Block();

            // Generate: if (task.Status != RanToCompletion) goto endOfNormalPostcondition;
            StatementList checkStatusStatements = CreateIfTaskResultIsEqualsTo(
                checkMethodTaskParameter, TaskStatus.RanToCompletion, endOfNormalPostcondition);

            methodBodyBlock.Statements.Add(new Block(checkStatusStatements));

            // Emit a check for __ContractsRuntime.insideContractEvaluation around Ensures
            this.rewriter.EmitRecursionGuardAroundChecks(this.checkPostMethod, methodBodyBlock, ensuresChecks);

            // Now, normal postconditions are written to the method body. 
            // We need to add endOfNormalPostcondition block as a marker.
            methodBodyBlock.Statements.Add(endOfNormalPostcondition);

            //
            // Exceptional postconditions
            //

            var exceptionalPostconditions = GetExceptionalEnsures(asyncPostconditions).ToList();
            if (exceptionalPostconditions.Count > 0)
            {
                // For exceptional postconditions we need to generate CheckException method first
                Method checkExceptionMethod = CreateCheckExceptionMethod();

                EmitCheckExceptionBody(checkExceptionMethod, exceptionalPostconditions);

                this.closureClass.Members.Add(checkExceptionMethod);

                // Then, we're using the same trick as for normal postconditions:
                // wrapping exceptional postconditions only when task.Status is TaskStatus.Faulted
                Block checkExceptionBlock = new Block(new StatementList());

                // Marker for endOfExceptionPostcondition
                Block endOfExceptionPostcondition = new Block();

                StatementList checkStatusIsException = CreateIfTaskResultIsEqualsTo(
                    checkMethodTaskParameter, TaskStatus.Faulted, endOfExceptionPostcondition);

                checkExceptionBlock.Statements.Add(new Block(checkStatusIsException));

                // Now we need to emit actuall check for exceptional postconditions

                // Emit: var ae = task.Exception;
                
                var aeLocal = new Local(aggregateExceptionType.Value);

                checkExceptionBlock.Statements.Add(
                    new AssignmentStatement(aeLocal,
                        new MethodCall(
                            new MemberBinding(checkMethodTaskParameter,
                                GetTaskProperty(checkMethodTaskParameter, "get_Exception")),
                            new ExpressionList())));

                // Emit: CheckException(ae);

                // Need to store method result somewhere, otherwise stack would be corrupted
                var checkResultLocal = new Local(SystemTypes.Boolean);

                checkExceptionBlock.Statements.Add(
                    new AssignmentStatement(checkResultLocal,
                            new MethodCall(new MemberBinding(null, 
                                checkExceptionMethod),
                            new ExpressionList(checkExceptionMethod.ThisParameter, aeLocal))));

                checkExceptionBlock.Statements.Add(endOfExceptionPostcondition);
                
                methodBody.Add(checkExceptionBlock);
            }

            // Copy original block to body statement for both: normal and exceptional postconditions.
            newBodyBlock.Statements.Add(origBody);

            Block returnBlock = CreateReturnBlock(checkMethodTaskParameter, lastEnsuresSourceContext);
            methodBody.Add(returnBlock);
        }

        private static IEnumerable<Ensures> GetTaskResultBasedEnsures(List<Ensures> asyncPostconditions)
        {
            return asyncPostconditions.Where(post => !(post is EnsuresExceptional));
        }

        private static IEnumerable<EnsuresExceptional> GetExceptionalEnsures(List<Ensures> asyncPostconditions)
        {
            return asyncPostconditions.OfType<EnsuresExceptional>();
        }

        /// <summary>
        /// Returns TaskExtensions.Unwrap method.
        /// </summary>
        [Pure]
        private static Member GetUnwrapMethod(TypeNode checkMethodTaskType)
        {
            Contract.Requires(checkMethodTaskType != null);
            Contract.Ensures(Contract.Result<Member>() != null);

            Contract.Assert(TaskExtensionsTypeNode != null, "Can't find System.Threading.Tasks.TaskExtensions type");

            var unwrapCandidates = TaskExtensionsTypeNode.GetMembersNamed(Identifier.For("Unwrap"));

            Contract.Assert(unwrapCandidates != null,
                "Can't find Unwrap method in the TaskExtensions type");

            // Should be only two methods. If that is not true, we need to change this code to reflect this!
            Contract.Assume(unwrapCandidates.Count == 2, "Should be exactly two candidate Unwrap methods.");

            // We need to find appropriate Unwrap method based on CheckMethod argument type.
            var firstMethod = (Method)unwrapCandidates[0];
            var secondMethod = (Method)unwrapCandidates[1];

            Contract.Assume(firstMethod != null && secondMethod != null);

            var genericUnwrapCandidate = firstMethod.IsGeneric ? firstMethod : secondMethod;
            var nonGenericUnwrapCandidate = firstMethod.IsGeneric ? secondMethod : firstMethod;

            if (checkMethodTaskType.IsGeneric)
            {
                // We need to "instantiate" generic first.
                // I.e. for Task<int> we need to have Unwrap(Task<Task<int>>): Task<int>
                return genericUnwrapCandidate.GetTemplateInstance(null, checkMethodTaskType.TemplateArguments[0]);
            }

            return nonGenericUnwrapCandidate;
        }

        /// <summary>
        /// Factory method that creates bool CheckException(Exception e)
        /// </summary>
        [Pure]
        private Method CreateCheckExceptionMethod()
        {
            Contract.Ensures(Contract.Result<Method>() != null);

            var exnParameter = new Parameter(Identifier.For("e"), SystemTypes.Exception);
            var checkExceptionMethod =
                new Method(
                    declaringType: this.closureClass,
                    attributes: null,
                    name: CheckExceptionMethodId,
                    parameters: new ParameterList(exnParameter),
                    returnType: SystemTypes.Boolean,
                    body: new Block(new StatementList()));

            checkExceptionMethod.Body.HasLocals = true;

            checkExceptionMethod.CallingConvention = CallingConventionFlags.HasThis;
            checkExceptionMethod.Flags |= MethodFlags.Public;

            if (checkExceptionMethod.ExceptionHandlers == null)
                checkExceptionMethod.ExceptionHandlers = new ExceptionHandlerList();

            return checkExceptionMethod;
        }

        private void EmitCheckExceptionBody(Method checkExceptionMethod, List<EnsuresExceptional> exceptionalPostconditions)
        {
            Contract.Requires(checkExceptionMethod != null);

            Contract.Requires(exceptionalPostconditions != null);
            Contract.Requires(exceptionalPostconditions.Count > 0);

            // We emit the following method:
            //   bool CheckException(Exception e) {
            //     var ex = e as C1;
            //     if (ex != null) {
            //       EnsuresOnThrow(predicate)
            //     }
            //     else {
            //       var ex2 = e as AggregateException;
            //       if (ex2 != null) {
            //         ex2.Handle(CheckException);
            //       }
            //     }
            //
            //     // Method always returns true. This is by design!
            //     // We need to check all exceptions in the AggregateException
            //     // and fail in EnsuresOnThrow if the postcondition is not met.
            //     return true; // handled

            var body = checkExceptionMethod.Body.Statements;
            var returnBlock = new Block(new StatementList());

            foreach (var e in exceptionalPostconditions)
            {
                // The catchBlock contains the catchBody, and then
                // an empty block that is used in the EH.
                // TODO ST: name is confusing because there is no catch blocks in this method!
                Block catchBlock = new Block(new StatementList());

                // local is: var ex1 = e as C1;
                Local localEx = new Local(e.Type);

                body.Add(
                    new AssignmentStatement(localEx,
                        new BinaryExpression(checkExceptionMethod.Parameters[0],
                            new MemberBinding(null, e.Type),
                            NodeType.Isinst)));

                Block skipBlock = new Block();
                body.Add(new Branch(new UnaryExpression(localEx, NodeType.LogicalNot), skipBlock));
                body.Add(catchBlock);
                body.Add(skipBlock);

                // call Contract.EnsuresOnThrow
                ExpressionList args = new ExpressionList();
                args.Add(e.PostCondition);

                args.Add(e.UserMessage ?? Literal.Null);

                args.Add(e.SourceConditionText ?? Literal.Null);

                args.Add(localEx);
                var checks = new StatementList();

                checks.Add(
                    new ExpressionStatement(
                        new MethodCall(
                            new MemberBinding(null, this.rewriter.RuntimeContracts.EnsuresOnThrowMethod),
                            args,
                            NodeType.Call,
                            SystemTypes.Void),
                        e.SourceContext));

                this.rewriter.CleanUpCodeCoverage.VisitStatementList(checks);

                // TODO ST: actually I can't see this recursion guard check in the resulting IL!!
                rewriter.EmitRecursionGuardAroundChecks(checkExceptionMethod, catchBlock, checks);

                catchBlock.Statements.Add(new Branch(null, returnBlock));
            }

            // recurse on AggregateException itself
            {
                // var ae = e as AggregateException;
                // if (ae != null) {
                //   ae.Handle(this.CheckException);
                // }
                Block catchBlock = new Block(new StatementList());
                var aggregateType = aggregateExceptionType.Value;

                // var ex2 = e as AggregateException;
                Local localEx2 = new Local(aggregateType);
                body.Add(
                    new AssignmentStatement(localEx2,
                        new BinaryExpression(
                            checkExceptionMethod.Parameters[0],
                            new MemberBinding(null, aggregateType),
                            NodeType.Isinst)));

                Block skipBlock = new Block();
                body.Add(new Branch(new UnaryExpression(localEx2, NodeType.LogicalNot), skipBlock));
                body.Add(catchBlock);
                body.Add(skipBlock);

                var funcType = func2Type.Value;
                funcType = funcType.GetTemplateInstance(this.rewriter.AssemblyBeingRewritten, SystemTypes.Exception, SystemTypes.Boolean);

                var handleMethod = aggregateType.GetMethod(Identifier.For("Handle"), funcType);

                var funcLocal = new Local(funcType);
                var ldftn =
                    new UnaryExpression(
                        new MemberBinding(null, checkExceptionMethod),
                        NodeType.Ldftn,
                        CoreSystemTypes.IntPtr);

                catchBlock.Statements.Add(
                    new AssignmentStatement(funcLocal,
                        new Construct(
                            new MemberBinding(null, funcType.GetConstructor(SystemTypes.Object, SystemTypes.IntPtr)),
                            new ExpressionList(checkExceptionMethod.ThisParameter, ldftn))));

                catchBlock.Statements.Add(
                    new ExpressionStatement(new MethodCall(new MemberBinding(localEx2, handleMethod),
                        new ExpressionList(funcLocal))));
            }

            // add return true to CheckException method
            body.Add(returnBlock);
            body.Add(new Return(Literal.True));
        }

        /// <summary>
        /// Returns property for the task object.
        /// </summary>
        private static Method GetTaskProperty(Parameter taskParameter, string propertyName)
        {
            Contract.Requires(taskParameter != null);
            Contract.Ensures(Contract.Result<Method>() != null);

            // For generic task Status property defined in the base class.
            // That's why we need to check what the taskParameter type is - is it generic or not.
            // If the taskParameter is generic we need to use base type (because Task<T> : Task).

            var taskTypeWithStatusProperty = taskParameter.Type.IsGeneric
                ? taskParameter.Type.BaseType
                : taskParameter.Type;

            return taskTypeWithStatusProperty.GetMethod(Identifier.For(propertyName));

        }

        /// <summary>
        /// Method returns a list of statements that checks task status.
        /// </summary>
        private static StatementList CreateIfTaskResultIsEqualsTo(
            Parameter taskParameterToCheck, TaskStatus expectedStatus,
            Block endBlock)
        {
            Contract.Ensures(Contract.Result<StatementList>() != null);

            var result = new StatementList();

            // If-statement is slightly different in IL.
            // To get `if (condition) {statements}`
            // we need to generate:
            // if (!condition) goto endBLock; statements; endBlock:

            // This method emits a check that simplifies CheckMethod implementation.

            var statusProperty = GetTaskProperty(taskParameterToCheck, "get_Status");
            Contract.Assert(statusProperty != null, "Can't find Task.Status property");

            // Emitting: var tmpStatus = task.Status;
            var tmpStatus = new Local(statusProperty.ReturnType);
            result.Add(
                new AssignmentStatement(tmpStatus,
                    new MethodCall(new MemberBinding(taskParameterToCheck, statusProperty),
                    new ExpressionList())));

            // if (tmpStatus != expectedStatus)
            // goto endOfMethod;
            // This is an inverted form of the check: if (tmpStatus == expectedStatus) {check}
            result.Add(
                new Branch(
                    new BinaryExpression(
                        tmpStatus,
                        new Literal(expectedStatus),
                        NodeType.Ne),
                    endBlock));

            return result;
        }

        private static Block CreateReturnBlock(Parameter checkPostTaskParameter, SourceContext? lastEnsuresSourceContext)
        {
            Statement returnStatement = new Return(checkPostTaskParameter);
            if (lastEnsuresSourceContext != null)
            {
                returnStatement.SourceContext = lastEnsuresSourceContext.Value;
            }

            Block returnBlock = new Block(new StatementList(1));
            returnBlock.Statements.Add(returnStatement);

            return returnBlock;
        }

        /// <summary>
        /// Returns correct version of the ContinueWith method.
        /// </summary>
        private static Method GetContinueWithMethod(Class closureClass, TypeNode taskTemplate, TypeNode taskType)
        {
            var continueWithCandidates = taskTemplate.GetMembersNamed(Identifier.For("ContinueWith"));

            for (int i = 0; i < continueWithCandidates.Count; i++)
            {
                var cand = continueWithCandidates[i] as Method;
                if (cand == null) continue;

                // For non-generic version we're looking for ContinueWith(Action<Task>)

                //if (taskType.TemplateArgumentsCount() == 0)
                if (!taskType.IsGeneric)
                {
                    if (cand.IsGeneric) continue;

                    if (cand.ParameterCount != 1) continue;

                    if (cand.Parameters[0].Type.GetMetadataName() != "Action`1") continue;

                    return cand;
                }

                // For generic version we're looking for ContinueWith(Func<Task, T>)
                if (!cand.IsGeneric) continue;

                if (cand.TemplateParameters.Count != 1) continue;

                if (cand.ParameterCount != 1) continue;

                if (cand.Parameters[0].Type.GetMetadataName() != "Func`2") continue;

                // now create instance, first of task
                var taskInstance = taskTemplate.GetTemplateInstance(
                    closureClass.DeclaringModule,
                    taskType.TemplateArguments[0]);

                // ST: some black magic is happening, but it seems it is required to get ContinueWith
                // from generic instantiated version of the task
                var candMethod = (Method)taskInstance.GetMembersNamed(Identifier.For("ContinueWith"))[i];

                // Candidate method would have following signature:
                // Task<T> ContinueWith(Task<T> t) for generic version
                return candMethod.GetTemplateInstance(null, taskType);
            }

            return null;
        }

        private static InstanceInitializer CreateConstructor(Class closureClass)
        {
            var ctor = new InstanceInitializer(closureClass, null, null, null);
            ctor.CallingConvention = CallingConventionFlags.HasThis;
            ctor.Flags |= MethodFlags.Public | MethodFlags.HideBySig;

            // Regular block that calls base class constructor
            ctor.Body = new Block(
                new StatementList(
                    new ExpressionStatement(
                        new MethodCall(new MemberBinding(ctor.ThisParameter, SystemTypes.Object.GetConstructor()),
                            new ExpressionList())),
                new Return()));
            return ctor;
        }

        private bool IsVoidTask()
        {
            return this.checkPostMethod.ReturnType == SystemTypes.Void;
        }

        // Visitor for changing closure locals to fields

        public override Expression VisitLocal(Local local)
        {
            if (HelperMethods.IsClosureType(this.declaringType, local.Type))
            {
                MemberBinding mb;
                if (!closureLocals.TryGetValue(local, out mb))
                {
                    // TODO ST: not clear what's going on here!
                    // Forwarder would be null, if enclosing method with async closure is not generic
                    var localType = forwarder != null ? forwarder.VisitTypeReference(local.Type) : local.Type;

                    var closureField = new Field(this.closureClass, null, FieldFlags.Public, local.Name, localType, null);
                    this.closureClass.Members.Add(closureField);

                    mb = new MemberBinding(this.checkPostMethod.ThisParameter, closureField);
                    closureLocals.Add(local, mb);

                    // initialize the closure field
                    var instantiatedField = Rewriter.GetMemberInstanceReference(closureField, this.closureClassInstance);
                    this.ClosureInitializer.Statements.Add(
                        new AssignmentStatement(
                            new MemberBinding(this.closureLocal, instantiatedField), local));
                }

                return mb;
            }

            return local;
        }
    }
}